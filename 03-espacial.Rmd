---
title: "02-redes"
author: "George G. Vega Yon"
date: "December 9, 2018"
output: html_document
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Notación y conceptos fundamentales

*   Matriz dispersa

*   Matriz normalizada

*   

## Autocorrelación

*   La I de Moran [@Moran1950]: Pregunta, ¿está la variable $X$ correlacionada a
    nivel espacial?
    
    $$
    I={\frac {N}{W}}{\frac {\sum _{i}\sum _{j}w_{ij}(x_{i}-{\bar {x}})(x_{j}-{\bar {x}})}{\sum _{i}(x_{i}-{\bar {x}})^{2}}}
    $$
    
    Donde $W$ es una matriz normalizada (*row-normalized*) 

## Spatial Autocorrelation Models (SAR a.k.a. Network Auto-correlation Models) {.smaller}

*   Spatial Auto-correlation Models are mostly applied in the context of spatial
    statistics and econometrics.
    
*   A wide family of models, you can find SA equivalents to Probit, Logit, MLogit, etc.
    
*   The SAR model has interdependence built-in using a Multivariate Normal Distribution:
    
    $$
    \begin{align}
    Y = & \alpha + \rho W Y + X\beta + \varepsilon,\quad\varepsilon\sim MVN(0,\sigma^2I_n)
    \end{align}
    $$

    Where $\rho\in[-1,1]$ and $W=\{w_{ij}\}$, with $\sum_j w_{ij} = 1$

## Spatial Autocorrelation Models (SAR) (cont.) {.smaller}

*   This is more close than we might think, since the $i$-th element of $Wy$ can be
    expressed as $\frac{\sum_j a_{ij} y_j}{\sum_j a_{ij}}$, what we usually
    define as exposure in networks, where $a_{ij}$ is an element of the $\{0,1\}$-adjacency
    matrix .
    
    
*   These models assume that $W$ is exogenous,
    in other words, if there's homophily you won't be able to use it!
    
*   But there are solutions to this problem (using instrumental variables).

## Qué Matriz?

*   La pregunta "Cual de todas las posibles matrices debo utilizar" es más
    común de lo que debería. 
    
*   

*   Notice that $(I_n - \rho W)^{-1} = I_n + \rho W + \rho^2 W^2 + \dots$, hence
    there autocorrelation does consider effects over neighbors farther than 1 step
    away, which makes the specification of $W$ no critical. [see @LeSage2008]

## Ejemplo con datos simulados

*   Para simular un modelo SAR, podemos seguir los siguientes pasos:
    
    1.  Generar una matriz de covariables $X$ junto con sus respectivos coeficientes,
    
    2.  Generar un vector $\varepsilon \sim N(0,1)$, pregunta: ¿Importa no utilizar
        la función MVN (`mvtnorm::rmvnorm`)?
        
    3.  Generar el vector $Y$ de la siguiente forma: 
    
        $$
        Y = \left(I_n -\rho W\right)^{-1}(\alpha + X\beta + \varepsilon)
        $$
        
        Donde $I_n$ es una matriz diagonal $n$.
        
## Ejemplo con datos simulados (cont.)



```{r ejemplo1-dgp}

# Parametros para la simulacion
set.seed(1151)
n   <- 500L
k   <- 2L
rho <- .5

# Simulando covariables y coeficientes
X   <- cbind(1, matrix(runif(n*k), ncol=k))
b   <- cbind(runif(k + 1L, -1, 1))
eps <- cbind(rnorm(n))

# Simulando matriz espacial, utilizaremos el paquete igraph para esto
library(igraph)
library(Matrix) # Para acceder al dgCMatrix en la funcion rowSums

# Modelo mundo pequeño parametros 8 (numero de vecinos) y .4 (probabilidad) de
# re-cableo.
net <- igraph::sample_smallworld(1, n, 8, .4)
W   <- as_adj(net)

# Normalizando matriz y visualizando
W   <- W/rowSums(W)
image(W)

# Generando variable dependiente
Y <- as.matrix(solve(diag(n) - rho*W) %*% (X %*% b + eps))
```

```{r ejemplo1-estimacion}
# Estimacion
library(spdep)

# La I de moran
netdiffuseR::moran(Y, W)

# OBS: La implentacion en netdiffuseR es significativamente mas rapida que la del
# paquete spdep (~ 100 veces en mi maquina).
# Wlist <- mat2listw(W)
# microbenchmark::microbenchmark(
#   netdiffuseR::moran(Y, W), # Para matrices realmente grandes
#   moran.test(Y, Wlist, alternative = "two.sided")  
# )


# Naive OLS
exposure <- as.matrix(W %*% Y)

summary(ans0 <- lm(Y ~ X[,-1]))
lm.morantest(ans0, listw = mat2listw(W))

netdiffuseR::moran(ans0$residuals, W)

# Modelos de regresion
ans1 <- lm(Y ~ exposure + X[,-1])
ans2 <- lagsarlm(Y ~ X[,-1], listw = mat2listw(W))
ans3 <- lagsarlm(Y ~ 0 + X, listw = mat2listw(W), Durbin = ~ X[,-1])

coef(ans0)
coef(ans1)
coef(ans2)
```




## Referencias
